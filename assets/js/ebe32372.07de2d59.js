"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[236],{7012:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api/validate-address","title":"Validate Address","description":"A tool for checking if a Bitcoin address is valid and determining its properties.","source":"@site/docs/api/validate-address.md","sourceDirName":"api","slug":"/api/validate-address","permalink":"/bitcoin-mcp/docs/api/validate-address","draft":false,"unlisted":false,"editUrl":"https://github.com/AbdelStark/bitcoin-mcp/tree/main/docs/docs/api/validate-address.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Generate Key","permalink":"/bitcoin-mcp/docs/api/generate-key"},"next":{"title":"Decode Transaction","permalink":"/bitcoin-mcp/docs/api/decode-tx"}}');var d=n(4848),t=n(8453);const a={sidebar_position:2},r="Validate Address",l={},c=[{value:"Tool Name",id:"tool-name",level:2},{value:"Description",id:"description",level:2},{value:"Input",id:"input",level:2},{value:"Output",id:"output",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Technical Details",id:"technical-details",level:2},{value:"Error Handling",id:"error-handling",level:2}];function o(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(i.header,{children:(0,d.jsx)(i.h1,{id:"validate-address",children:"Validate Address"})}),"\n",(0,d.jsx)(i.p,{children:"A tool for checking if a Bitcoin address is valid and determining its properties."}),"\n",(0,d.jsx)(i.h2,{id:"tool-name",children:"Tool Name"}),"\n",(0,d.jsx)(i.p,{children:(0,d.jsx)(i.code,{children:"validate_address"})}),"\n",(0,d.jsx)(i.h2,{id:"description",children:"Description"}),"\n",(0,d.jsx)(i.p,{children:"Validates Bitcoin addresses by checking their format, checksum, and network compatibility. This tool helps ensure addresses are correctly formatted before sending transactions or using them in applications."}),"\n",(0,d.jsx)(i.h2,{id:"input",children:"Input"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsxs)(i.li,{children:[(0,d.jsx)(i.code,{children:"address"}),": The Bitcoin address to validate (string)"]}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:"output",children:"Output"}),"\n",(0,d.jsx)(i.p,{children:"Returns validation details including:"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"Whether the address is valid"}),"\n",(0,d.jsx)(i.li,{children:"The address type (P2PKH, P2SH, etc.)"}),"\n",(0,d.jsx)(i.li,{children:"The network (mainnet/testnet)"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,d.jsx)(i.p,{children:"Using the tool through Claude:"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{children:"Is this Bitcoin address valid: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa?\n"})}),"\n",(0,d.jsx)(i.p,{children:"Example output:"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{children:"I'll check if that Bitcoin address is valid using the validate_address tool.\n\nThe address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa is valid:\n- Type: P2PKH (Pay to Public Key Hash)\n- Network: Mainnet\n- Format: Legacy (starts with '1')\n\nThis is a valid Bitcoin address that can safely be used to receive funds on the main Bitcoin network.\n"})}),"\n",(0,d.jsx)(i.p,{children:"Another example:"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{children:"Can you validate this address: 1234abcd?\n"})}),"\n",(0,d.jsx)(i.p,{children:"Example output:"}),"\n",(0,d.jsx)(i.pre,{children:(0,d.jsx)(i.code,{children:"I'll check that address using the validate_address tool.\n\nThe address \"1234abcd\" is NOT valid:\n- Incorrect length\n- Invalid checksum\n- Improper format\n\nA valid Bitcoin address should be longer and follow specific format rules. For example, a legacy Bitcoin address starts with '1' and is about 34 characters long.\n"})}),"\n",(0,d.jsx)(i.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"Verifying addresses before sending transactions"}),"\n",(0,d.jsx)(i.li,{children:"Validating user input in applications"}),"\n",(0,d.jsx)(i.li,{children:"Checking address network compatibility"}),"\n",(0,d.jsx)(i.li,{children:"Identifying address types for compatibility checks"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,d.jsx)(i.p,{children:"The tool performs several checks:"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"Base58Check decoding"}),"\n",(0,d.jsx)(i.li,{children:"Checksum verification"}),"\n",(0,d.jsx)(i.li,{children:"Network prefix validation"}),"\n",(0,d.jsx)(i.li,{children:"Address format identification"}),"\n",(0,d.jsx)(i.li,{children:"Length validation"}),"\n",(0,d.jsx)(i.li,{children:"Character set validation"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,d.jsx)(i.p,{children:"The tool provides clear feedback when validation fails, including:"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"Format errors (invalid characters, wrong length)"}),"\n",(0,d.jsx)(i.li,{children:"Network mismatches"}),"\n",(0,d.jsx)(i.li,{children:"Checksum failures"}),"\n",(0,d.jsx)(i.li,{children:"Invalid address types"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,d.jsx)(i,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>r});var s=n(6540);const d={},t=s.createContext(d);function a(e){const i=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:a(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);